---
import Layout from '../../../layouts/Layout.astro';
import Navigation from '../../../components/git-cheatsheet/Navigation.astro';
---

<Layout title="タグ・高度な操作編 - Gitコマンドチートシート" description="Git のタグ管理、Cherry-pick、サブモジュール、ワークツリー、Bisect など高度な操作を解説。">
  <main>
    <header class="page-header">
      <h1>タグ・高度な操作編</h1>
      <p class="subtitle">タグ管理、Cherry-pick、サブモジュール、ワークツリー、Bisect、高度な操作</p>
    </header>

    <Navigation currentPage="advanced" />

    <article>
      <section id="tag">
        <h2>11. タグ管理</h2>
        <p>
          リリースバージョンなど、特定のコミットに目印を付けるタグ機能。
          軽量版タグと注釈付きタグの違いも解説します。
        </p>

        <h3>タグの作成</h3>
        <p>
          タグには軽量版タグと注釈付きタグの2種類があります。
          リリース用としては注釈付きタグを推奨します。
        </p>
        <div class="command-block">
          <h4>注釈付きタグ（推奨）</h4>
          <pre><code># 注釈付きタグを作成
git tag -a v1.0.0 -m "Release version 1.0.0"

# 現在のコミットにタグを付ける
git tag -a v1.0.1 -m "Bug fix release"

# 特定のコミットにタグを付ける
git tag -a v1.0.0 abc123 -m "Version 1.0.0"

# エディタで詳細なメッセージを入力
git tag -a v1.0.0</code></pre>

          <h4>軽量版タグ</h4>
          <pre><code># 軽量版タグを作成（メッセージなし）
git tag v1.0.0

# 特定のコミットに軽量版タグ
git tag v1.0.0 abc123

# 軽量版タグの特徴
# - タグ名のみを保存
# - 作成者や日時などのメタデータなし
# - 一時的な目印用</code></pre>
        </div>

        <h3>タグの一覧と確認</h3>
        <p>
          リポジトリ内のタグを確認する方法です。
        </p>
        <div class="command-block">
          <pre><code># すべてのタグを一覧表示
git tag

# パターンでタグを絞り込み
git tag -l "v1.*"
git tag --list "v2.0.*"

# タグの詳細情報を表示
git show v1.0.0

# タグを作成日順でソート
git tag --sort=-creatordate

# 最新のタグを表示
git describe --tags
git describe --tags --abbrev=0  # タグ名のみ</code></pre>
        </div>

        <h3>タグのプッシュ</h3>
        <p>
          デフォルトではタグはpushされません。明示的にプッシュする必要があります。
        </p>
        <div class="command-block">
          <pre><code># 特定のタグをpush
git push origin v1.0.0

# すべてのタグをpush
git push origin --tags
git push --tags

# コミットとタグを一緒にpush
git push --follow-tags

# デフォルトで--follow-tagsを使用する設定
git config --global push.followTags true</code></pre>
        </div>

        <h3>タグの削除</h3>
        <p>
          ローカルとリモートのタグを削除する方法です。
        </p>
        <div class="command-block">
          <pre><code># ローカルタグを削除
git tag -d v1.0.0
git tag --delete v1.0.0

# リモートタグを削除
git push origin --delete v1.0.0
git push origin :refs/tags/v1.0.0  # 古い書き方

# 複数のタグを削除
git tag -d v1.0.0 v1.0.1 v1.0.2
git push origin --delete v1.0.0 v1.0.1 v1.0.2</code></pre>
        </div>

        <h3>タグを使ったチェックアウト</h3>
        <p>
          特定のタグの状態にチェックアウトする方法です。
        </p>
        <div class="command-block">
          <pre><code># タグをチェックアウト（detached HEAD状態）
git checkout v1.0.0

# タグから新しいブランチを作成
git checkout -b hotfix-1.0.1 v1.0.0
git switch -c hotfix-1.0.1 v1.0.0

# タグ間の差分を確認
git diff v1.0.0 v1.1.0
git log v1.0.0..v1.1.0</code></pre>
        </div>

        <h3>タグのベストプラクティス</h3>
        <p>
          リリース運用で推奨されるタグの付け方です。
        </p>
        <div class="command-block">
          <pre><code># タグ命名規則の例
v1.0.0        # Semantic Versioning
v2.1.3-rc.1   # リリースキャンディデート
v1.0.0-beta.2 # ベータ版
release-2024-01 # 日付ベース

# 推奨されるプラクティス
# ✅ 注釈付きタグを使用
# ✅ Semantic Versioningに従う
# ✅ 詳細なリリースノートを記載
# ✅ タグ作成後は変更しない
# ❌ 軽量版タグを公開リリースに使用</code></pre>
        </div>
      </section>

      <section id="cherry-pick">
        <h2>12. Cherry-pick（特定コミットの適用）</h2>
        <p>
          他のブランチから特定のコミットだけを現在のブランチに取り込む機能。
          バグ修正のバックポートなどに役立ちます。
        </p>

        <h3>基本的なCherry-pick</h3>
        <p>
          特定のコミットを現在のブランチに適用します。
        </p>
        <div class="command-block">
          <pre><code># 特定のコミットを適用
git cherry-pick abc123

# 複数のコミットを適用
git cherry-pick abc123 def456 ghi789

# コミット範囲を適用
git cherry-pick abc123..def456
git cherry-pick abc123^..def456  # abc123も含む

# 最新のコミットを適用
git cherry-pick feature-branch</code></pre>
        </div>

        <h3>オプション付きCherry-pick</h3>
        <p>
          より柔軟なCherry-pick操作です。
        </p>
        <div class="command-block">
          <pre><code># コミットせずにステージングのみ
git cherry-pick --no-commit abc123
git cherry-pick -n abc123
# 変更内容を確認して手動でコミット

# メッセージを編集
git cherry-pick -e abc123
git cherry-pick --edit abc123

# 元のコミット者情報を保持（デフォルト）
git cherry-pick abc123

# 空のコミットも適用
git cherry-pick --allow-empty abc123</code></pre>
        </div>

        <h3>コンフリクトの解決</h3>
        <p>
          Cherry-pick中にコンフリクトが発生した場合の対処法です。
        </p>
        <div class="command-block">
          <pre><code># Cherry-pickでコンフリクトが発生
git cherry-pick abc123
# CONFLICT...

# 1. コンフリクトを解決
# エディタで修正

# 2. 解決したファイルをステージング
git add conflicted-file.txt

# 3. Cherry-pickを続行
git cherry-pick --continue

# Cherry-pickを中断して元に戻す
git cherry-pick --abort

# 現在のコミットをスキップ
git cherry-pick --skip</code></pre>
        </div>

        <h3>実用例</h3>
        <p>
          Cherry-pickの実践的な使用例です。
        </p>
        <div class="command-block">
          <h4>バグ修正のバックポート</h4>
          <pre><code># シナリオ: mainで修正したバグをreleaseブランチにも適用

# 1. mainでバグ修正
git checkout main
git commit -m "Fix critical bug"
# コミットSHA: abc123

# 2. releaseブランチに切り替え
git checkout release-1.0

# 3. 修正を適用
git cherry-pick abc123
git push origin release-1.0</code></pre>

          <h4>特定の機能だけを取り込む</h4>
          <pre><code># シナリオ: featureブランチから特定のコミットだけがmainに欲しい

# 1. 必要なコミットSHAを確認
git log feature-branch --oneline

# 2. mainに切り替え
git checkout main

# 3. 必要なコミットだけを適用
git cherry-pick abc123 def456</code></pre>
        </div>

        <h3>注意点</h3>
        <p>
          Cherry-pickの使いどころと注意事項です。
        </p>
        <div class="command-block">
          <pre><code># Cherry-pickの注意点

# ⚠️ コミット履歴が複雑になる
# - 同じ変更が複数のブランチに存在
# - 履歴の追跡が困難になる

# ✅ 使うべきケース
# - バグ修正のバックポート
# - 緊急のホットフィックス
# - 特定の機能だけを取り込む

# ❌ 避けるべきケース
# - 通常のブランチマージ
# - 大量のコミットの移動
# - 依存関係のあるコミット群</code></pre>
        </div>
      </section>

      <section id="submodule">
        <h2>13. サブモジュール</h2>
        <p>
          他のGitリポジトリをプロジェクトに組み込むサブモジュール機能。
          ライブラリ管理や共通コードの共有に便利です。
        </p>

        <h3>サブモジュールの追加</h3>
        <p>
          外部リポジトリをサブモジュールとして追加します。
        </p>
        <div class="command-block">
          <pre><code># サブモジュールを追加
git submodule add https://github.com/user/library.git lib/library

# 特定のブランチを追跡
git submodule add -b main https://github.com/user/library.git lib/library

# サブモジュール追加後のコミット
git add .gitmodules lib/library
git commit -m "Add library as submodule"</code></pre>
        </div>

        <h3>サブモジュールを含むリポジトリのクローン</h3>
        <p>
          サブモジュールを含むプロジェクトをクローンする方法です。
        </p>
        <div class="command-block">
          <pre><code># サブモジュールも含めてクローン
git clone --recurse-submodules https://github.com/user/project.git

# 既にクローン済みの場合
git submodule init
git submodule update
# または一行で
git submodule update --init --recursive

# 全サブモジュールを初期化して更新
git submodule update --init --recursive</code></pre>
        </div>

        <h3>サブモジュールの更新</h3>
        <p>
          サブモジュールを最新の状態に更新します。
        </p>
        <div class="command-block">
          <pre><code># 全サブモジュールを更新
git submodule update --remote

# 特定のサブモジュールを更新
git submodule update --remote lib/library

# サブモジュール内で作業
cd lib/library
git checkout main
git pull
cd ../..

# 親リポジトリでサブモジュールの変更をコミット
git add lib/library
git commit -m "Update library submodule"

# 全サブモジュールでコマンドを実行
git submodule foreach 'git pull origin main'
git submodule foreach 'git checkout main'</code></pre>
        </div>

        <h3>サブモジュールの状態確認</h3>
        <p>
          サブモジュールの現在の状態を確認する方法です。
        </p>
        <div class="command-block">
          <pre><code># サブモジュールの状態を表示
git submodule status

# 詳細なサブモジュール情報
git submodule

# サブモジュールの設定を確認
cat .gitmodules

# サブモジュールの概要を表示
git submodule summary</code></pre>
        </div>

        <h3>サブモジュールの削除</h3>
        <p>
          サブモジュールをプロジェクトから削除する方法です。
        </p>
        <div class="command-block">
          <pre><code># サブモジュールを削除（Git 2.13以降）
git submodule deinit lib/library
git rm lib/library
git commit -m "Remove library submodule"

# .git/modulesも削除する場合
rm -rf .git/modules/lib/library

# 古いGitの場合の手順
git submodule deinit lib/library
git rm lib/library
rm -rf .git/modules/lib/library
git commit -m "Remove library submodule"</code></pre>
        </div>

        <h3>サブモジュールの注意点</h3>
        <p>
          サブモジュールの利点と運用上の注意です。
        </p>
        <div class="command-block">
          <pre><code># サブモジュールの特徴

# ✅ 利点
# - 外部ライブラリのバージョン管理
# - 複数プロジェクトでのコード共有
# - 独立したリポジトリとして管理

# ⚠️ 注意点
# - サブモジュールは特定のコミットに固定される
# - 更新は手動で行う必要がある
# - チーム全員がサブモジュールを理解する必要がある
# - 初心者には複雑に感じるかもしれない

# サブモジュールの代替手段
# - npm/yarnなどのパッケージマネージャー
# - Git Subtree（よりシンプル）
# - モノレポ構成</code></pre>
        </div>
      </section>

      <section id="worktree">
        <h2>14. ワークツリー</h2>
        <p>
          同じリポジトリで複数のブランチを同時に操作できるワークツリー機能。
          異なる機能を並行で開発する際に便利です。
        </p>

        <h3>ワークツリーの作成</h3>
        <p>
          新しいワークツリーを作成して、複数のブランチで作業できるようにします。
        </p>
        <div class="command-block">
          <pre><code># 新しいブランチでワークツリーを作成
git worktree add ../project-feature feature-branch

# 新しいブランチを作成してワークツリーを作成
git worktree add -b new-feature ../project-new-feature

# 特定のコミットからワークツリーを作成
git worktree add ../project-hotfix abc123

# detached HEADでワークツリーを作成
git worktree add --detach ../project-temp abc123</code></pre>
        </div>

        <h3>ワークツリーの一覧と確認</h3>
        <p>
          現在のワークツリーを確認する方法です。
        </p>
        <div class="command-block">
          <pre><code># ワークツリーの一覧を表示
git worktree list

# 詳細情報付きで表示
git worktree list --porcelain</code></pre>
        </div>

        <h3>ワークツリーでの作業</h3>
        <p>
          複数のワークツリーで並行作業する方法です。
        </p>
        <div class="command-block">
          <pre><code># メインの作業ディレクトリ
cd ~/project
git worktree add ../project-feature feature-a

# feature-aで作業
cd ../project-feature
# ... 作業 ...
git add .
git commit -m "Work on feature A"

# メインに戻って別の作業
cd ~/project
# ... mainブランチで作業 ...

# 両方の変更が独立して管理される</code></pre>
        </div>

        <h3>ワークツリーの削除</h3>
        <p>
          不要になったワークツリーを削除します。
        </p>
        <div class="command-block">
          <pre><code># ワークツリーを削除
git worktree remove ../project-feature

# ロックされているワークツリーを強制削除
git worktree remove --force ../project-feature

# 手動でディレクトリを削除した場合のクリーンアップ
rm -rf ../project-feature
git worktree prune

# 古い・無効なワークツリー情報を削除
git worktree prune</code></pre>
        </div>

        <h3>ワークツリーの移動</h3>
        <p>
          ワークツリーを別の場所に移動する方法です。
        </p>
        <div class="command-block">
          <pre><code># ワークツリーを移動
git worktree move ../project-feature ../new-location/project-feature

# ロックされているワークツリーを強制移動
git worktree move --force ../project-feature ../new-location/</code></pre>
        </div>

        <h3>実用例</h3>
        <p>
          ワークツリーの実践的な使用例です。
        </p>
        <div class="command-block">
          <h4>緊急のバグ修正</h4>
          <pre><code># シナリオ: 機能開発中に緊急のバグ修正が必要に

# 1. 現在の作業を続けながら、別ディレクトリでhotfix
cd ~/project  # featureブランチで作業中
git worktree add ../project-hotfix -b hotfix/critical-bug main

# 2. hotfixで作業
cd ../project-hotfix
# ... 修正 ...
git commit -m "Fix critical bug"
git push origin hotfix/critical-bug

# 3. 元の作業に戻る
cd ~/project
# featureブランチの作業を続ける</code></pre>

          <h4>レビュー用環境</h4>
          <pre><code># シナリオ: PRのレビューを現在の作業を中断せずに行う

# 1. レビュー用ワークツリーを作成
git worktree add ../project-review pr-branch

# 2. レビュー
cd ../project-review
# ... コードを確認、テスト ...

# 3. レビュー後に削除
cd ~/project
git worktree remove ../project-review</code></pre>
        </div>

        <h3>ワークツリーの利点</h3>
        <p>
          ブランチ切り替えとの違いと、運用時の注意点です。
        </p>
        <div class="command-block">
          <pre><code># ワークツリー vs ブランチ切り替え

# ✅ ワークツリーの利点
# - 作業を中断せずに別ブランチで作業可能
# - stashが不要
# - IDE/エディタの状態を保持
# - ビルド成果物を保持
# - 複数のブランチで同時にテスト実行

# ⚠️ 注意点
# - ディスク容量を消費する
# - 複数のディレクトリを管理する必要がある
# - node_modulesなどの依存関係が複数作成される</code></pre>
        </div>
      </section>

      <section id="bisect">
        <h2>15. バグの特定（Bisect）</h2>
        <p>
          バグが混入したコミットを二分探索で特定するBisect機能。
          大規模なコミット履歴から効率的に問題箇所を見つけられます。
        </p>

        <h3>手動Bisect</h3>
        <p>
          手動でテストしながらバグの原因を特定します。
        </p>
        <div class="command-block">
          <pre><code># 1. Bisectを開始
git bisect start

# 2. 現在のコミット（バグあり）をbadとマーク
git bisect bad

# 3. 正常に動作していたコミットをgoodとマーク
git bisect good abc123

# 4. Gitが自動的に中間のコミットをチェックアウト
# Bisecting: 5 revisions left to test after this

# 5. テストして結果を報告
# バグがある場合
git bisect bad
# バグがない場合
git bisect good

# 6. 繰り返すと原因のコミットが特定される
# xyz789 is the first bad commit

# 7. Bisectを終了
git bisect reset</code></pre>
        </div>

        <h3>自動Bisect</h3>
        <p>
          テストスクリプトを使用して自動的にバグを特定します。
        </p>
        <div class="command-block">
          <pre><code># 自動Bisectを開始
git bisect start HEAD abc123

# テストスクリプトで自動実行
git bisect run npm test

# テストスクリプトの終了コード
# 0: 成功（good）
# 1-127（125除く）: 失敗（bad）
# 125: スキップ

# 自作スクリプトの例
# test.sh
#!/bin/bash
make && make test
exit $?

git bisect run ./test.sh</code></pre>
        </div>

        <h3>Bisectの高度な使い方</h3>
        <p>
          より柔軟なBisect操作です。
        </p>
        <div class="command-block">
          <pre><code># 特定のパスを変更したコミットだけを対象にテスト
git bisect start HEAD abc123 -- path/to/file.js

# コミットをスキップ
git bisect skip

# 複数のコミットをスキップ
git bisect skip v2.5..v2.6

# 現在のBisectの状態を表示
git bisect log

# Bisectの状態を視覚化
git bisect visualize
gitk bisect/bad --not bisect/good

# Bisectを一時停止して別の作業
git bisect reset  # 一旦終了
# ... 作業 ...
git bisect start
git bisect good abc123
git bisect bad def456  # 再開</code></pre>
        </div>

        <h3>実用例</h3>
        <p>
          Bisectの実践的な使用例です。
        </p>
        <div class="command-block">
          <h4>パフォーマンス問題の特定</h4>
          <pre><code># シナリオ: いつからかパフォーマンスが悪化した

# ベンチマークスクリプトを作成（終了コード 0=good, 非0=bad）
# benchmark.sh
#!/bin/bash
npm run benchmark
exit $?

# Bisectで原因を特定
git bisect start HEAD v1.0.0
git bisect run ./benchmark.sh</code></pre>

          <h4>ビルドエラーの特定</h4>
          <pre><code># シナリオ: いつからかビルドが失敗するようになった

git bisect start HEAD v2.0.0
git bisect run sh -c "npm install && npm run build"</code></pre>
        </div>

        <h3>Bisectのベストプラクティス</h3>
        <p>
          効率的にBisectを行うためのヒントです。
        </p>
        <div class="command-block">
          <pre><code># 効果的なBisectのためのヒント

# ✅ 準備
# - 明確なgoodコミットを特定
# - 再現可能なテスト手順を用意
# - 自動テストがあれば活用

# ✅ 効率化
# - ビルドエラーがあるコミットはskip
# - 特定のファイルに絞って検索
# - タグやリリースを基準にする

# ⚠️ 注意
# - ビルド環境を清潔に保つ
# - キャッシュをクリアする
# - 環境変数や設定の影響に注意</code></pre>
        </div>
      </section>

      <section id="advanced-ops">
        <h2>16. 高度な操作</h2>
        <p>
          さらに高度なGitコマンドを紹介。
          reflog、clean、blame、grepなど、特定の状況で役立つコマンドを学びます。
        </p>

        <h3>Reflog（リファレンスログ）</h3>
        <p>
          HEADや各ブランチの移動履歴を記録するログ。誤って削除したコミットを復元できます。
        </p>
        <div class="command-block">
          <pre><code># Reflogを表示
git reflog
git reflog show HEAD

# 特定のブランチのreflog
git reflog show main

# 詳細なreflog
git reflog show --all

# 誤って削除したコミットを復元
git reflog
# abc123 HEAD@{1}: commit: Important work
git checkout abc123
git branch recovered-work

# 誤ってresetした場合の復元
git reset --hard HEAD@{1}

# Reflogの有効期限（デフォルト: 90日）
git config --global gc.reflogExpire "90 days"</code></pre>
        </div>

        <h3>Clean（未追跡ファイルの削除）</h3>
        <p>
          未追跡ファイルやディレクトリを削除して、作業ディレクトリを清潔にします。
        </p>
        <div class="command-block">
          <pre><code># ドライラン（実際には削除しない）
git clean -n
git clean --dry-run

# 未追跡ファイルを削除
git clean -f
git clean --force

# 未追跡ディレクトリも削除
git clean -fd

# .gitignoreのファイルも削除
git clean -fdx

# 対話的に削除
git clean -i
git clean --interactive

# 特定のパターンを除外して削除
git clean -fdx -e '*.log'  # *.log 以外の未追跡ファイルを削除</code></pre>
        </div>

        <h3>Blame（各行の最終変更者）</h3>
        <p>
          ファイルの各行がいつ、誰によって変更されたかを確認できます。
        </p>
        <div class="command-block">
          <pre><code># ファイルの各行の最終変更者を表示
git blame file.txt

# 特定の行範囲を表示
git blame -L 10,20 file.txt
git blame -L 10,+10 file.txt  # 10行目から10行分

# メールアドレスを表示
git blame -e file.txt

# コミットSHAを短く表示
git blame -s file.txt

# 特定のコミット時点でのblame
git blame abc123 file.txt

# 空白やインデントの変更を無視
git blame -w file.txt</code></pre>
        </div>

        <h3>Grep（コード検索）</h3>
        <p>
          Gitの履歴を通じてコードを検索します。
        </p>
        <div class="command-block">
          <pre><code># 現在の作業ディレクトリで検索
git grep "function_name"

# 行番号を表示
git grep -n "function_name"

# ヒット数をカウント
git grep -c "TODO"

# 複数のパターンを検索
git grep -e "pattern1" --and -e "pattern2"
git grep -e "pattern1" --or -e "pattern2"

# 特定のファイルタイプで検索
git grep "function" -- "*.js"

# 特定のコミットで検索
git grep "pattern" abc123

# 前後の行も表示
git grep -C 3 "pattern"  # 前後3行
git grep -B 2 -A 1 "pattern"  # 前2行、後1行</code></pre>
        </div>

        <h3>Archive（アーカイブ作成）</h3>
        <p>
          リポジトリのスナップショットをアーカイブファイルとして作成します。
        </p>
        <div class="command-block">
          <pre><code># ZIPアーカイブを作成
git archive --format=zip --output=project.zip HEAD

# tar.gzアーカイブを作成
git archive --format=tar.gz --output=project.tar.gz HEAD

# 特定のタグでアーカイブ
git archive --format=zip --output=v1.0.0.zip v1.0.0

# 特定のディレクトリのみアーカイブ
git archive --format=zip --output=src.zip HEAD:src/

# プレフィックス付きでアーカイブ
git archive --format=tar --prefix=project-1.0/ HEAD | gzip &gt; project-1.0.tar.gz</code></pre>
        </div>

        <h3>Bundle（リポジトリのバックアップ）</h3>
        <p>
          Gitリポジトリ全体を1つのファイルにバンドルします。
        </p>
        <div class="command-block">
          <pre><code># 全ブランチをバンドル
git bundle create repo.bundle --all

# 特定のブランチをバンドル
git bundle create repo.bundle main develop

# バンドルからクローン
git clone repo.bundle project

# バンドルの内容を確認
git bundle verify repo.bundle
git bundle list-heads repo.bundle

# バンドルからfetch
cd existing-repo
git fetch ../repo.bundle main:refs/remotes/bundle/main</code></pre>
        </div>

        <h3>Fsck（リポジトリの整合性チェック）</h3>
        <p>
          リポジトリの破損や問題を検出します。
        </p>
        <div class="command-block">
          <pre><code># リポジトリの整合性チェック
git fsck

# 詳細なチェック
git fsck --full

# 失われたオブジェクトを検出
git fsck --lost-found

# ガベージコレクションを実行
git gc
git gc --aggressive --prune=now</code></pre>
        </div>

        <h3>Show（オブジェクトの表示）</h3>
        <p>
          様々なGitオブジェクトの内容を表示します。
        </p>
        <div class="command-block">
          <pre><code># コミットの詳細を表示
git show abc123

# 特定のファイルの内容を表示
git show abc123:path/to/file.txt

# タグの詳細を表示
git show v1.0.0

# 差分のみ表示（メッセージなし）
git show --no-patch abc123
git show -s abc123

# 特定のファイルの変更のみ表示
git show abc123 -- path/to/file.txt</code></pre>
        </div>
      </section>
    </article>

    <Navigation currentPage="advanced" />

    <footer class="page-footer">
      <p><a href="/cheatsheets/git-cheatsheet">目次に戻る</a> | <a href="/">トップページに戻る</a></p>
    </footer>
  </main>
</Layout>

<style>
  main {
    max-width: 900px;
    margin: 0 auto;
    padding: 2rem 1rem;
    line-height: 1.7;
  }

  .page-header {
    text-align: center;
    margin-bottom: 2rem;
    padding-bottom: 1.5rem;
    border-bottom: 2px solid #667eea;
  }

  h1 {
    font-size: 2.5rem;
    margin-bottom: 0.5rem;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }

  .subtitle {
    font-size: 1.1rem;
    color: #666;
  }

  article section {
    margin-bottom: 3rem;
    padding-bottom: 2rem;
    border-bottom: 1px solid #eee;
  }

  article section:last-of-type {
    border-bottom: none;
  }

  h2 {
    font-size: 1.8rem;
    margin-bottom: 1rem;
    color: #333;
    padding-top: 1rem;
  }

  h3 {
    font-size: 1.4rem;
    margin-top: 2rem;
    margin-bottom: 1rem;
    color: #444;
    border-bottom: 2px solid #f0f0f0;
    padding-bottom: 0.5rem;
  }

  h4 {
    font-size: 1.1rem;
    margin-top: 1.5rem;
    margin-bottom: 0.75rem;
    color: #555;
  }

  p {
    margin-bottom: 1rem;
    color: #444;
  }

  .command-block {
    background: #f8f9fa;
    border-left: 4px solid #667eea;
    padding: 1.5rem;
    margin: 1.5rem 0;
    border-radius: 4px;
  }

  .command-block h4 {
    margin-top: 0;
    margin-bottom: 1rem;
    color: #667eea;
  }

  pre {
    background: #2d2d2d;
    color: #f8f8f2;
    padding: 1rem;
    border-radius: 4px;
    overflow-x: auto;
    margin: 1rem 0;
  }

  code {
    font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
    font-size: 0.9rem;
    line-height: 1.5;
  }

  .note {
    background: #fff3cd;
    border-left: 4px solid #ffc107;
    padding: 0.75rem 1rem;
    margin: 1rem 0;
    font-style: italic;
    color: #856404;
  }

  .page-footer {
    text-align: center;
    margin-top: 3rem;
    padding-top: 2rem;
    border-top: 2px solid #667eea;
    color: #666;
  }

  .page-footer a {
    color: #667eea;
    text-decoration: none;
  }

  .page-footer a:hover {
    text-decoration: underline;
  }
</style>
